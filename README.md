# netwhat

## 넷마스크(Netmask), 서브넷 마스크(Subnet Mask)
네트워크 주소 부분의 비트를 1로 치환한 것.

## 네트워크 주소
하나의 네트워크를 통칭하기 위한 주소

## 해당 네트워크의 첫번째 IP주소
계산법 : IP주소와 서브넷마스크 &연산
브로드캐스트 주소
특정 네트워크에 속하는 모든 호스트들이 갖게되는 주소. 네트워크에 있는 클라이언트 모두에게 데이터를 보내기위함

해당 네트워크에 속하는 IP주소중 가장마지막 주소
계산 방법 : 서브넷마스크 의 1의 보수이다.

## 서브네팅이란?
네트워크 관리자가 네트워크 성능을 향상시키기 위해 자원을 효율적으로 분배하는 것, 자원을 효율적으로 분배한다는 것은 네트워크 영역과 호스트 영역을 분할 하는 것이다.

네트워크적인 측면에서는 너무 큰 브로드케스트 도메인은 네트워크 환경에서 패킷전송을 느리게하고 성능저하를 발생시킨다.

따라서 네트워크를 쪼개서 통신성능을 보장한다. 또한 IP는 32자리 2진수로 표현할 수 있다.

이 말은 최대 2의 32승 까지 표현가능한데 제한적인 자원으로 인해 주소에 낭비없이 아껴써야한다.

그래서 등장한 것이 서브넷 마스크이다.

서브넷 마스크는 필요한 네트워크 주소만 호스트 IP로 할당 할 수 있게 만들어 네트워크 낭비를 방지합니다. 이를 서브네팅이라한다.
기본 서브넷 마스크(Default Subnet Mask)
IP를 클래스로 나눈 다는것은, 결국 서브넷마스크를 사용한다는 말과 같은 의미이다.

예를들어 C클래스를 사용하면, C클래스 네트워크를 그대로 사용하는 것이므로 255.255.255.0이 기본 서브넷 마스크가 된다.

별개의 서브넷마스크를 생성하지 않아도 기본적으로 적용되어 있는게 기본 서브넷 마스크이다.

A 클래스의 경우 기본서브넷 마스크는 255.0.0.0

B 클래스의 경우 기본서브넷 마스크는 255.255.0.0

C 클래스의 경우 기본서브넷 마스크는 255.255.255.0

## 넷마스크와 서브넷 마스크의 차이점
CIDR이후 둘은 구분하고 있지않다. IPv4 초창기 실절에 A, B, C 급으로 네트워크를 나눠썼는데, CIDR이후 큰 네트워크 주소를 쪼개면서, 서브넷마스크가 생겨난 것이다.(1~32bitmask가 가능하게 하기위하여)

## CIDR이란?
CIDR(사이더) 은 Classless Inter-Domain Routing 으로 클래스없는 도메인간 라우팅 기법이라는 뜻이다.

클래스가 없다는 뜻은 네트워크 구분을 Class로 하지 않는다는 것이다. Class는 사이더가 나오기전 사용했던 네트워크 구분 체계이다.

사이더가 나오면서 class체계보다 더유연하게 IP주소를 여러 네트워크 영역으로 나눌수있게 되었다.

예를들어 IP뒤에 192.168.10.0/24 이런식으로 “/24” 와 같은것을 사이더 표기법이라한다.

서브넷 마스크 표시방법
서브넷마스크는 1과 0으로 이루어져 있고, 1이 연속으로 나와야합니다.

예를 들어 1111 1111 . 1111 1111 . 1111 1111 . 0000 0000 이런 서브넷마스크가 있을때

1은 네트워크영역으로 사용하겠다는 뜻이고, 0은 호스트 IP로 사용하겠다는 뜻입니다. 사용자에게 0으로 표현된 부분만 호스트 IP를 할당할수 있게 만들겠다는 뜻입니다.

별개의 서브넷마스크를 생성하지 않아도 기본적으로 적용되어 있는게 기본 서브넷마스크이고, 기본서브넷마스크로 쪼개진 네트워크 주소를 서브넷 네트워크라고 합니다.

IP주소와 서브넷마스크를 &연산하면 서브넷 네트워크를 구할 수 있습니다.

이런 기본 서브넷마스크뿐만아니라, 사용자가 서브넷마스크를 원하는 대로 사용하여, 좀더 자유롭게 서브넷마스크를 할당하여, 네트워크영역과 호스팅영역을 더 쪼개서 효율적으로 서브네팅합니다. (ex. 1111 1111 . 1111 1111 . 1111 1111 . 1100)

## Private IP 와 Public IP
## Private IP
사설 IP주소는 같은 네트워크안에서 서로 통신하는데 사용하는 시스템이다. 같은 네트워크안에서 개인적인 IP data나 정보사용을 주고 받을 수 있다.

## Public IP
네트워크 바깥과 통신하는 IP주소 시스템이다. Public IP주소는 기본적으로 ISP(Internet Service Provider)에게 할당되어 있다.

Private IP	Public IP
local	global
개인 또는 회사의 기기	개인 또는 회사의 서버
한 네트워크 안에서 유일	인터넷 상에서 유일
라우터	ISP에 의하여 작동함
무료	유료
Private IP범위

10.0.0.0 ~ 10.255.255.255 172.16.0.0 ~ 172.31.255.255 192.168.0.0 ~ 192.168.255.255

Public IP범위

Private IP 주소외에 나머지는 Public IP이다.

## Network Layer
Network Layer의 주된 역할은 보내는 호스트에서 받는 호스트로 Packets을 보내는 것이다.
Network Layer의 주된기능
Routing : 패킷이 라우터의 입력 링크에 도달하면 라우터는 라우터의 출력링크로 패킷을 이동한다.
Logical Addressing : 데이터 링크 계층은 물리적 주소지정을 구현하고 네트워크 계층은 논리적 주소 지정을 구현한다. 또한 소스시스템과 대상 시스템을 구별하는데 논리 주소 지정이 사용된다. 네트워크 계층은 송신자와 수신자 모두의 논리적 주소를 포함하는 헤더를 패킷에 추가한다.
InternetWorking : 네트워크 계층이 서로 다른 유형의 네트워크 간에 논리적 연결을 제공하는 주요 역할이다.
Fragmentation : 패킷을 서로 다른 네트워크를 통해 이동하는 최소 개별 데이터 단위로 분할 하는 프로세스
OSI 7 Layer(계층)이 탄생한 이유
통신에 관한 국제표준기구인 ISO(International Organization for Standardization)라는 곳에서 통신이 일어나는 과정을 7단계로 나누고 표준화 시켰다.

이유는 다음과 같다.

데이터의 흐름을 한눈에 볼 수 있다.
문제를 해결하기 편하다.
여러장비를 써도 네트워크간 호환이 된다.
PDU
Process Data Unit 각 계층에서 전송되는 단위

## OSI 7 Layer 순서
하위계층 (물리->데이터링크->네트워크)->상위계층(전송->세션->표현->응용)

Physical Layer
맨 아래 계층으로 주로 전기적, 기계적, 기능적인 특성을 이용하여 통신케이블로 데이터를 전송, 피지컬은 단지 데이터만 전달할 뿐 어떻게 보내는 것이 효율적인지, 어떤 종류의 데이터인지, 에러가 있는지는 관심이 없다.

프로토콜 : modem, Cable, Fiber, RS-232C
장비 : 허브, 리피터
Data-Link Layer
오류없이 한 장치에서 다른 장치로 프레임(비트의 모음)을 전달하는 역할, 3계층에서 정보를 받아 주소와 제어정보를 시작과 끝에 추가

PDU : 프레임
프로토콜 : 이더넷 , MAC, PPP, ATM, LAN, Wifi
장비 : 브릿지, 스위치
Network Layer
다중 네트워크에 링크에서 패킷을 발신지로부터 목적지로 전달할 책임을 갖는다. 2계층은 노드대노드 전달을 감독하는 것이고 3계층은 각 패킷이 시작 시점에서 최종목적지까지 성공적이고 효과적으로 전달되도록한다.

PDU : 패킷
프로토콜 : IP, ICMP, IGMP
장비 : 라우터
Transprot Layer
전체 메시지를 발신지 대 목적지 간 제어와 에러를 관리한다. 패킷들의 전송이 유효한지 확인하고 실패한 패킷은 다시보내는 등 신뢰성있는 통신을 보장하며, 머리말에는 세그먼트가 포함된다.

PDU : 세그먼트
프로토콜 : TCP, UDP
장비 : 게이트웨이
Session Layer
통신세션을 구성하는 계층으로, 포트 연결이라고 할 수 있다. 통신 장치간의 상호작용을 설정하고 유지하며 동기화한다. 사용자간의 포트 연결이 유효한지 확인하고 설정한다.

프로토콜 : SSH, TLS
Presentation Layer
운영체계의 한 부분으로 입력 또는 출력되는 데이터를 하나의 표현형태로 변환한다. 필요한 번역을 수행하여 두 장치가 일관되게 전송 데이터를 서로 이해할 수 있도록한다. 제어코드나 문자 및 그래픽등의 확장자(jpg, gif, mpg)를 생각하면된다.

프로토콜 : JPEG, MPEG, SMB, AFP
Application Layer
사용자가 네트워크에 접근할 수 있도록 해주는 계층이다. 사용자 인터페이스, 전자우편, 데이터베이스 관리등 서비스를 제공한다.

프로토콜 : DHCP, DNS, FTP, HTTP


## 인터넷 프로토콜 스위트 TCP/IP 프로토콜 슈트
인터넷에서 컴퓨터들이 서로 정보를 주고받는 데 쓰이는 통신규약(프로토콜)의 모음이다.

인터넷 프로토콜 슈트 중 TCP와 IP가 가장 많이 쓰이기 떄문에 TCP/IP 프로토콜 슈트라고도 불린다.

TCP와 IP
TCP/IP 는 패킷 통신 방식의 인터넷 프로토콜인 IP와 전송 조절 프로토콜인 TCP로 이루어져 있다.

IP는 패킷 전달여부를 보증하지 않고, 패킷을 보낸 순서와 받는 순서가 다를 수 있다.

TCP는 IP위에서 동작하는 프로토콜로, 데이터의 전달을 보증하고 보낸순서대로 받게 해준다.

HTTP, FTP, SMTP등 TCP를 기반으로 한 많은 수의 애플리케이션 프로토콜들이 IP위에서 동작하기 떄문에, 묶어서 TCP/IP로 부르기도 한다.

인터넷 프로토콜 스택의 계층 구조
TCP/IP
응용 계층
전송 계층
인터넷 계층
네트워크 인터페이스 계층
TCP
전송 제어 프로토콜(Transmission Control Protocol)로 네트워크 계층 중 전송 계층에서 사용하는 프로토콜이다.

장치들 사이에 논리적인 접속을 성립하기위하여 연결을 설정하여 신뢰성을 보장하는 연결형 서비스이다.

TCP는 네트워크에 연결된 컴퓨터에서 실행되는 프로그램 간에 일련의 옥텟(데이터, 메세지, 세그먼트라는 블록단위)를 안정적으로 , 순서대로, 에러없이 교환할 수 있게 한다.

TCP의 특징
연결형 서비스
연결형 서비스로 가상 회선 방식을 제공한다.

3-way handshaking과정을 통해 연결을 설정
4-way handshaking을 통해 연결을 해제
흐름제어(Flow control)
데이터 처리속도를 조절하여 수신자의 버퍼 오버플로우를 방지

송신하는 곳에서 감당이 안되게 많으 데이터를 빠르게 보내 수신하는 곳에서 문제가 일어나는 것을 막는다.
수신자가 윈도우크기 값을 통해 수신량을 정할 수 있다.
혼잡제어(Congestion control)
네트워크 내의 패킷 수가 넘치게 증가하지 않도록 방지

정보의 소통량이 과다하면 패킷을 조금만 전송하여 혼잡 붕괴현상이 일어나는 것을 막는다.
신뢰성이 높은 전송(Reliable transmission)
Dupack-based retransmission
정상적인 상황에서는 ACK 값이 연속적으로 전송되어야 한다. 그러나 ACK값이 중복으로 올 경우 패킷 이상을 감지하고 재전송을 요청한다.

Timeout-based retransmission
일정시간동안 ACK값이 수신을 못할 경우 재전송을 요청한다.

전이중, 점대점 방식
전이중 (Full-Duplex)
전송이 양방향으로 동시에 일어날 수 있다.

점대점(Point to Point)
각 연결이 정확히 2개의 종단점을 가지고 있다.

멀티캐스팅이나 브로드캐스팅을 지원하지않는다.

TCP Header정보
응용계층으로부터 데이터를 받은 TCP는 헤더를 추가한 후에 이를 IP로 보낸다.

헤더에는 다음과같은 정보가 포함된다.

## 필드	내용	크기(bit)
송수신자 포트번호	TCP로 연결되는 가상회선 양단의 송수신 프로세스에 할당되는 포트주소	16
Sequence Number	송신자가 지정하는 순서 번호, 전송되는 바이트수를 기준으로 증가.	32
ACK Number	수신 프로세스가 제대로 수신한 바이트의 수를 응답하기 위해 사용	32
Data Offset	TCP세그먼트의 시작위치를 기준으로 데이터의 시작 위치를 표현	4
Reserved	사용을 하지 않지만 나중을 위한 예약 필드이며 0으로 채워져야한다.	6
Flag bit	SYN,ACK,FIN등의 제어번호	6
Window	수신 윈도우의 버퍼크기를 지정할 떄 사용. 0이면 송신 프로세스의 전송 중지	16
Checksum	TCP 세그먼트에 포함되는 포로토콜 헤더와ㅣ 데이터에 대한 오류 검출 용도	16
Urgent Point	긴급데이터를 처리하기 위함, URG플래그 비트가 지정된 경우에만 유효	16
제어비트
URG : 긴급위치를 필드가 유효한지 설정
ACK : 응답번호 필드가 유효한지 설정. 클라이언트가 보낸 최초의 SYN패킷 이후에 전송되는 모든 패킷은 이 플래그가 설정되어야한다. 송신측에 대하여 수식측에서 긍정 응답으로 보내지는 전송제어용 캐릭터, ACK번호를 사용하여 패킷이 도착했는지 확인한다. 송신한 패킷이 제대로 도착하지 않았으면 재송신을 요구한다.
PSH : 수신 애플리케이션에 버퍼링된 데이터를 상위계층에 즉시 전달할 때 사용
RST : 연결의 리셋이나 유효하지 않은 세그먼트에 대한 응답용
SYN : 연결 설정 요구. 동기화 시퀸스 번호. 양쪽이 보낸 최초의 패킷에만 이 플래그가 설정되어 있어여한다.
FIN : 더이상 전송할 데이터가 없을 때 연결 종료의사 표시
TCP Connection
TCP Connection (3-way handshake)
먼저 open()을 실행한 클라이언트가 SYN을 보내고 SYN_SENT 상태로 대기한다.
서버는 SYR_RCVD 상태로 바꾸고 SYN과 응답 ACK를 보낸다.
SYN과 응답 ACK을 받은 클라이언트는 ESTABLISHED 상태로 변경하고 서버에게 응답 ACK를 보낸다.
응답 ACK를 받은 서버는 ESTABLISHED 상태로 변경한다
TCP Disconnection(4-way handshake)
먼저 close()를 실행한 클라이언트가 FIN을 보내고 FIN_WAIT1상태로 대기한다.
서버는 CLOSE_WAIT으로 바꾸고 응답 ACK를 전달한다. 동시에 해당 포트에 연결되어 있는 어플리케이션에게 close()를 요청한다.
ACK를 받은 클라이언트 상태를 FIN_WAIT2로 변경한다.
close() 요청을 받은 서버 어플리케이션은 종료프로세스를 진행하고 FIN을 클라이언트에 보내 LAST_ACK상태로 바꾼다
FIN을 받은 클라이언트는 ACK 서버에 다시 전송하고 TIME_WAIT상태를 바꾼다. TIME_WAIT에서 일정 시간이 지나면 CLOSED된다. ACK를 받은 서버도 포트를 CLOSED로 닫는다.
UDP
User Datagram Protocol의 약자이다. TCP와 마찬가지로 TCP/IP의 전송계층에서 사용되는 프로토콜이다.

UDP 헤더 정보
응용 계층으로부터 받은 데이터를 UDP헤더를 추가한 후에 이를 IP로 보낸다.

필드	크기	내용
송신자의 포트번호	16	데이터를 보내는 애플리케이션의 포트번호
수신자의 포트번호	16	데이터를 받을 애플리케이션의 포트번호
데이터의 길이	16	UDP헤더와 데이터의 총길이
Checksum	16	데이터 오류검사에 사용
TCP 와 UDP 의 공통점과 차이점
공통점
포트번호를 이용하여 주소를 지정
데이터 오류 검사를 위한 체크섬 존재
차이점
TCP	UDP
연결지향형 프로토콜	비연결지향형 프로토콜
바이트 스트림을 통한 연결	메세지 스트림을 통한 연결
혼잡제어,흐름제어	혼잡,흐름제어없음
순서보장 상대적으로 느림	순서보장되지않음 상대적으로 빠름
신뢰성있는 데이터전송	데이터 전송 보장 x
세그먼트 TCP패킷	데이터그램 UDP패킷
HTTP,Email,File Transfer	DNS,Broadcasting(도메인,스트리밍)
데이터의 경계를 구분안함	데이터의 경계를 구분함
일대일 통신	일대일, 일대다(broadcasting), 다대다(multicasting) 통신
## DHCP
동적 호스트 설정 프로토콜(Dynamic Host Configuration Protocol)로서 해당 호스트에게 IP주소, 서브넷 마스크, 기본 게이트웨이 IP주소, DNS서버 IP주소를 자동으로 일정시간 할당해주는 인터넷 프로토콜

유동 IP할당 = DHCP 서버로부터 IP를 DHCP서버에서 설정해놓은 사용시간만큼 임대해온다.
DHCP 서버
DHCP 서버는 인터넷을 제공해주는 곳의 서벙에서 실행되는 프로그램으로 일정한 범위의 IP주소를 다른 클라이언트에게 할당하여 자동으로 설정하게 해주는 역할을한다.

DHCP서버는 클라이언트에게 할당된 IP주소를 변경없이 유지해 줄 수 있다. DHCP가 설정해주는 주소정보들은 IP주소, 서브넷마스크, 기본 게이트웨이, DNS서버 IP주소 가 있다.

DHCP 클라이언트
클라이언트들은 시스템이 시작하면 DHCP서버에 자신의 시스템을 위한 IP주소를 요청하고 DHCP서버로부터 IP주소를 부여받으면 TCP/IP설정은 초기화되고 다른 호스트와 TCP/IP를 사용해서 통신을 할 수 있게 된다.

DHCP Lease 절차
1. DHCP Server Discovery
새롭게 도착한 호스트는 자ㅣ신이 접속될 네트워크의 DHCP서버 주소를 알지 못한다. 따라서 호스트는 DHCP서버 발견 메시지를 브로드캐스트 IP주소(출발지 : 0.0.0.0, 목적지 : 255.255.255.255)로 캡슐화하여 서브넷 상의 모든 노드로 전송한다.

2. DHCP Server Offer
DHCP 발견 메시지를 받은 DHCP 서버는 DHCP 제공메시지를 이용해 클라이언트로 브로드캐스트한다. 송신 호스트의 IP주소가 할당되기 전이기 떄문에 DHCP서버는 서브넷 상의 모든 호스트로 응답하는 것이다. 서버 제공메시지는 클라이언트에 제공될 IP주소 네트워크 마스크, 도메인 이름, IP 주소 임대기간 등의 클라이언트 설정 파라미터 값이 포함된다.

3. DHCP Request
IP할당을 요청한 새 호스트는 하나 이상의 DHCP서버 제공 메시지를 받고 그 중 가장 최적의 서버를 선택한 후 그 서버측으로 DHCP 요청메시지를 보낸다.

4. DHCP ACK
서버는 DHCP 요청메시지에 대해 요청된 설정을 확인하는 ACK메시지를 전송한다.

## DNS
DNS(Domain Name Server)란 무엇인가?
인터넷은 서버들을 유일하게 구분할 수 있는 IP주소를 기본체계로 이용하는데 숫자로 이루어진 조합이라 인간이 기억하기에는 무리가 따른다.

따라서 DNS를 이용해 IP주소를 인간이 기억하기 편한 언어체계로 변환하는 작업을 DNS가 한다.

DNS 구조
1단계 : ROOT DNS 서버
2단계 : 최상위도메인 DNS 서버
3단계 : 책임 DNS 서버(희망문자열)
DNS 동작과정
www.naver.com 을 찾는 과정

DNS Client(웹 브라우저 등) 로컬 DNS에게 www.naver.com 을 질의한다.
로컬 DNS가 Root DNS에게 www.naver.com 을 묻는다.
Root DNS가 com을 인색하고 com을 관리하는 최상위 도메인 DNS서버의 IP를 로컬 DNS에게 알려준다.
다시 로컬 DNS가 com도메인을 관리하는 최상위 도메인 DNS서버에게 www.naver.com 을 질의한다.
최상위 도메인 DNS서버가 naver.com 을 인식하고 naver.com을 관리하는 책임 DNS서버의 IP를 로컬 DNS에게 알려준다.
로컬 DNS는 책임 DNS서버에게 www.naver.com 을 질의한다.
책임 DNS서버에서 www.naver.com 호스트에 대한 IP를 알려준다.
로컬 DNS가 DNS Client에게 www.naver.com의 IP를 알려준다.

## Routing
데이터를 목적지까지 전달하기 위한 모든 일련의 과정을 통틀어 Routing이라 한다.
데이터가 목적지까지 갈 수 있는 여러 경로중 한가지 경로를 설정해주는 과정
하나의 컴퓨터로 자신이 속하지 않은 네트워크에 속한 PC와 통신할 때 발생된 패킷을 목적지까지 전달해 주는 과정
Routing 을 위해 필요한 것
출발지와 목적지의 네트워크 정보
출발지와 목적지를 알아야 모든 경로를 검색할 수 있다.

목적지로 가는 모든경로
모든경로를 알아야 최적경로 선택 가능

최적경로
모든경로중 최적화된 경로 하나를 선택한다.

이경로를 저장하는 곳을 Routing Table이라한다.

L3장비는 이 Table 정보를 사용하여 패킷을 전달한다.

지속적인 네트워크 상태확인
경로가 어딘지 알지만 만약 그 경로가 Down된 상태라서 사용할 수 없는 경우일수도 있기 때문에

Routing 다른 네트워크로의 경로결정
목적지까지 갈 수 있는 모든 가능성있는 경로들 중에서 가장 효율적이라고 판단되는 경로정보는 패킷을 전달할 때 바로 참고해서 사용할 수 있도록 따로 모아두는데

이 모아둔 공간을 라우팅 테이블(Routing Table)이라 한다.

라우터는 전달받은 패킷의 목적지 주소를 자신의 Routing Table과 비교하여 어느 라우터에게 넘겨줄지를 판단하게 된다.

따라서 라우팅 프로토콜의 가장중요한 목적이 바로 Routing Table 설정이다.

Connected
자신과 물리적으로 직접 연결되어 있는 네트워크 주소를 학습해온 경우

Redistribution
재분배라고 하며 서로 다른 Routing Protocol 간에 정보를 주고 받을 때 사용

Static Routing
네트워크 관리자가 패킷의 경로를 임의로 결정하여 수동으로 구성하는 라우팅방식

네트워크 환경 변화와는 무관하게 항상 같은 경로로만 패킷 라우팅 경로를 설정 유지한다.

장점
관리자의 의도대로 제어할 수 있다.
경로정보를 주고 받을 필요없어 효율이 높다.
단점
경로를 설정하고 유지하는데 공수가 든다.
적절한 경로 구현을 위해 관리자의 이해도가 필요하다.
네트워크 규모가 커지면 경로설정하기 어렵다.
Dynamic Routing
인접한 라우터들 사이에서 라우팅 프로토콜을 이용하여 네트워크 정보를 상호 교환하며, 라우팅 테이블을 상시 자동적으로 생성하고 유지하는 라우팅 방식

상황에 따라서 적합한 길을 찾아내는게 가능한 프로토콜

RIP, OSPF, EIGRP 등 이 다이나믹 방식에속함

장점
관리자의 설정유지를 위한 작업이 적다.
경로의 특성에 대한 정보를 주고 받아 상황에 따라 적합한 경로를 선택 할 수 있다.
단점
CPU, 메모리, 링크 대역폭등 자원을 사용한다.
여러 정보를 가지게 되어 데이터 전송속도가 느려진다.
## Default Gateway
통신을 할 때 상대방의 IP 주소를 찾아 우선 내부 네트워크를 먼저 뒤지고 만약 없다면 외부로 나가게 되는데,

내부 네트워크에서 통신을 할 경우에는 라우터가 필요 없지만 외부로 나가게 된다면 라우터를 통해 밖으로 나가게 된다.

이 때 밖으로 나가기 위해서는 라우터의 문을 통과 해야하는데 이 문이 바로 게이트 웨이이다.

즉, 기본 게이트웨이란 내부 네트워크에서 없는 녀석을 찾아 밖으로 나갈 때 통해 있는 문이 되고, 이것은 바로 라우터의 이더넷 인터페이스 주소가 된다.

이더넷 인터페이스 주소
내부 네트워크에 접속되기 때문에 이더넷 인터페이스용 IP 주소는 우리가 내부에서 사용하기 위해 부여받은 IP 주소중 하나를 배정해야 한다.

보통 그 네트워크의 맨 첫번째 주소를 할당 해 준다.

## PORT(가상의 소프트웨어적인 포트)
port 번호는 TCP와 UDP가 상위 계층에 제공하는 주소 표현 방식이다.

소켓 시스템 콜을 이용해 TCP연결 설정이 되면 통신 양단의 프로세스가 사용하는 고유 주소는 해당 호스트의 IP 주소와 호스트 내부의 포트번호이다.

클라이언트 서버의 연동은 서버가 먼저 실행되고, 클라이언트가 서버와 연결을 시도하는 방법으로 이루어진다.

이때 연결을 원하는 서버와 접촉하려면 서버의 IP주소와 포트 번호를 알아야한다.

자주 사용하는 응용 서비스는 모두 고정된 포트 번호를 사용한다. (FTP, SMTP, HTTP, DNS 등)

사용자가 직접 포트번호를 지정하는 경우는 없다.

사용자가 연결을 원하는 서버의 호스트 IP주소만 클라이언트 프로그램에게 지정하고, 포트 번호 선택은 프로그램이 알아서 해준다.

TDP와 UDP는 별도의 포트 주소공간을 관리하므로 동일한 포트번호를 사용할 수 있다.

프로토콜 규약인 TCP/IP에서 지정한 포트로, 하드웨어적인 연결이 된 네트워크 망에서, PC끼리 서로 통신을 하는데 필요한 규약이다.

TCP/IP에서 통신을 할떄 동시다발적인 통신을 가능케 하기 위하여 포트라는 것이 정의된것

포트사용의 목적은

호스트 내에서 다중 포로세스에 대한 처리이다.(동시에 여러가지 일을 하는 것)
표기된 포트 번호에 따라 데이터가ㅣ 정확한 응용프로그램에서 처리 될수 있다.

어느 응용프로그램이나 사용자가 보낸 데이터 인지를 구분하기 위해 송신측 포트 번호가 사용되고

어느 응용 프로그램이 수신해야 하는지를 구분하기 위해 수신측 포트 번호가 사용됩니다.

동적으로 포트번호 할당
어떤 장치가 서비스를 제공하기 위해 필요 할 떄 그 장치들이 사용하는 포트번호가 중복이 되거나 불일치가 일어나지 않도록 번호를 임의로 생성하여 사용하는 방법

포트 번호와 전송층 프로토콜
TCP 사용하는 포트번호는 다른 전송층 프로토콜에서도 사용할 수 있다.

서로 다른 전송층 프로토콜은 서로다른 프로세스로 인식되기 때문
